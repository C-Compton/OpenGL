.TH "events.c" 3 "Sat Dec 1 2012" "Version 001" "OpenGL Flythrough" \" -*- nroff -*-
.ad l
.nh
.SH NAME
events.c \- 
.PP
Handles wiimote events\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <math\&.h>\fP
.br
\fC#include 'definitions\&.h'\fP
.br
\fC#include 'io\&.h'\fP
.br
\fC#include 'wiic_internal\&.h'\fP
.br
\fC#include 'dynamics\&.h'\fP
.br
\fC#include 'ir\&.h'\fP
.br
\fC#include 'nunchuk\&.h'\fP
.br
\fC#include 'classic\&.h'\fP
.br
\fC#include 'guitar_hero_3\&.h'\fP
.br
\fC#include 'events\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBSTATE_CHANGED\fP(a, b)   if (a != b)				return 1"
.br
.ti -1c
.RI "#define \fBCROSS_THRESH\fP(last, now, thresh)"
.br
.ti -1c
.RI "#define \fBCROSS_THRESH_XYZ\fP(last, now, thresh)"
.br
.ti -1c
.RI "#define \fBCROSS_THRESH_RATE\fP(last, now, thresh)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBidle_cycle\fP (struct \fBwiimote_t\fP *wm)"
.br
.RI "\fICalled on a cycle where no significant change occurs\&. \fP"
.ti -1c
.RI "void \fBclear_dirty_reads\fP (struct \fBwiimote_t\fP *wm)"
.br
.RI "\fIClear out all old 'dirty' read requests\&. \fP"
.ti -1c
.RI "void \fBpropagate_event\fP (struct \fBwiimote_t\fP *wm, \fBbyte\fP event, \fBbyte\fP *msg)"
.br
.RI "\fIAnalyze the event that occured on a wiimote\&. \fP"
.ti -1c
.RI "static void \fBevent_data_read\fP (struct \fBwiimote_t\fP *wm, \fBbyte\fP *msg)"
.br
.RI "\fIReceived a data packet from a read request\&. \fP"
.ti -1c
.RI "static void \fBevent_status\fP (struct \fBwiimote_t\fP *wm, \fBbyte\fP *msg)"
.br
.RI "\fIRead the controller status\&. \fP"
.ti -1c
.RI "static void \fBhandle_expansion\fP (struct \fBwiimote_t\fP *wm, \fBbyte\fP *msg)"
.br
.RI "\fIHandle data from the expansion\&. \fP"
.ti -1c
.RI "static void \fBsave_state\fP (struct \fBwiimote_t\fP *wm)"
.br
.RI "\fISave important state data\&. \fP"
.ti -1c
.RI "static int \fBstate_changed\fP (struct \fBwiimote_t\fP *wm)"
.br
.RI "\fIDetermine if the current state differs significantly from the previous\&. \fP"
.ti -1c
.RI "int \fBwiic_poll\fP (struct \fBwiimote_t\fP **wm, int wiimotes)"
.br
.RI "\fIPoll the wiimotes for any events\&. \fP"
.ti -1c
.RI "void \fBwiic_pressed_buttons\fP (struct \fBwiimote_t\fP *wm, \fBbyte\fP *msg)"
.br
.RI "\fIFind what buttons are pressed\&. \fP"
.ti -1c
.RI "void \fBhandshake_expansion\fP (struct \fBwiimote_t\fP *wm, \fBbyte\fP *data, unsigned short len)"
.br
.RI "\fIHandle the handshake data from the expansion device\&. \fP"
.ti -1c
.RI "void \fBdisable_expansion\fP (struct \fBwiimote_t\fP *wm)"
.br
.RI "\fIDisable the expansion device if it was enabled\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Handles wiimote events\&. 

The file includes functions that handle the events that are sent from the wiimote to us\&. 
.PP
Definition in file \fBevents\&.c\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define CROSS_THRESH(last, now, thresh)"
\fBValue:\fP
.PP
.nf
do {                                                          \
                    if (WIIMOTE_IS_FLAG_SET(wm, WIIC_ORIENT_THRESH)) {      \
                        if ((diff_f(last\&.roll, now\&.roll) >= thresh) ||            \
                            (diff_f(last\&.pitch, now\&.pitch) >= thresh) ||      \
                            (diff_f(last\&.yaw, now\&.yaw) >= thresh))                \
                        {                                                       \
                            last = now;                                         \
                            return 1;                                           \
                        }                                                       \
                    } else {                                                    \
                        if (last\&.roll != now\&.roll)        return 1;               \
                        if (last\&.pitch != now\&.pitch)  return 1;               \
                        if (last\&.yaw != now\&.yaw)      return 1;               \
                    }                                                           \
                } while (0)
.fi
.SS "#define CROSS_THRESH_RATE(last, now, thresh)"
\fBValue:\fP
.PP
.nf
do {                                                            \
                    if (WIIMOTE_IS_FLAG_SET(wm, WIIC_ORIENT_THRESH)) {      \
                        if ((diff_f(last\&.roll, now\&.roll) >= thresh) ||                \
                            (diff_f(last\&.pitch, now\&.pitch) >= thresh) ||              \
                            (diff_f(last\&.yaw, now\&.yaw) >= thresh))                    \
                        {                                                       \
                            last = now;                                         \
                            return 1;                                           \
                        }                                                       \
                    } else {                                                    \
                        if (last\&.roll != now\&.roll)        return 1;                   \
                        if (last\&.pitch != now\&.pitch)      return 1;                   \
                        if (last\&.yaw != now\&.yaw)      return 1;                   \
                    }                                                           \
                } while (0)
.fi
.SS "#define CROSS_THRESH_XYZ(last, now, thresh)"
\fBValue:\fP
.PP
.nf
do {                                                         \
                    if (WIIMOTE_IS_FLAG_SET(wm, WIIC_ORIENT_THRESH)) {      \
                        if ((diff_f(last\&.x, now\&.x) >= thresh) ||              \
                            (diff_f(last\&.y, now\&.y) >= thresh) ||              \
                            (diff_f(last\&.z, now\&.z) >= thresh))                    \
                        {                                                       \
                            last = now;                                         \
                            return 1;                                           \
                        }                                                       \
                    } else {                                                    \
                        if (last\&.x != now\&.x)      return 1;                   \
                        if (last\&.y != now\&.y)      return 1;                   \
                        if (last\&.z != now\&.z)      return 1;                   \
                    }                                                           \
                } while (0)
.fi
.SH "Function Documentation"
.PP 
.SS "void clear_dirty_reads (struct \fBwiimote_t\fP *wm)"

.PP
Clear out all old 'dirty' read requests\&. \fBParameters:\fP
.RS 4
\fIwm\fP Pointer to a \fBwiimote_t\fP structure\&. 
.RE
.PP

.PP
Definition at line 226 of file events\&.c\&.
.SS "void disable_expansion (struct \fBwiimote_t\fP *wm)"

.PP
Disable the expansion device if it was enabled\&. \fBParameters:\fP
.RS 4
\fIwm\fP A pointer to a \fBwiimote_t\fP structure\&. 
.br
\fIdata\fP The data read in from the device\&. 
.br
\fIlen\fP The length of the data block, in bytes\&.
.RE
.PP
If the data is NULL then this function will try to start a handshake with the expansion\&. 
.PP
Definition at line 709 of file events\&.c\&.
.SS "static void event_data_read (struct \fBwiimote_t\fP *wm, \fBbyte\fP *msg)\fC [static]\fP"

.PP
Received a data packet from a read request\&. \fBParameters:\fP
.RS 4
\fIwm\fP Pointer to a \fBwiimote_t\fP structure\&. 
.br
\fImsg\fP The message specified in the event packet\&.
.RE
.PP
Data from the wiimote comes in packets\&. If the requested data segment size is bigger than one packet can hold then several packets will be received\&. These packets are first reassembled into one, then the registered callback function that handles data reads is invoked\&. 
.PP
Definition at line 421 of file events\&.c\&.
.SS "static void event_status (struct \fBwiimote_t\fP *wm, \fBbyte\fP *msg)\fC [static]\fP"

.PP
Read the controller status\&. \fBParameters:\fP
.RS 4
\fIwm\fP Pointer to a \fBwiimote_t\fP structure\&. 
.br
\fImsg\fP The message specified in the event packet\&.
.RE
.PP
Read the controller status and execute the registered status callback\&. 
.PP
Definition at line 528 of file events\&.c\&.
.SS "static void handle_expansion (struct \fBwiimote_t\fP *wm, \fBbyte\fP *msg)\fC [static]\fP"

.PP
Handle data from the expansion\&. \fBParameters:\fP
.RS 4
\fIwm\fP A pointer to a \fBwiimote_t\fP structure\&. 
.br
\fImsg\fP The message specified in the event packet for the expansion\&. 
.RE
.PP

.PP
Definition at line 598 of file events\&.c\&.
.SS "void handshake_expansion (struct \fBwiimote_t\fP *wm, \fBbyte\fP *data, unsigned shortlen)"

.PP
Handle the handshake data from the expansion device\&. \fBParameters:\fP
.RS 4
\fIwm\fP A pointer to a \fBwiimote_t\fP structure\&. 
.br
\fIdata\fP The data read in from the device\&. 
.br
\fIlen\fP The length of the data block, in bytes\&.
.RE
.PP
Tries to determine what kind of expansion was attached and invoke the correct handshake function\&.
.PP
If the data is NULL then this function will try to start a handshake with the expansion\&. 
.PP
Definition at line 634 of file events\&.c\&.
.SS "static void idle_cycle (struct \fBwiimote_t\fP *wm)\fC [static]\fP"

.PP
Called on a cycle where no significant change occurs\&. \fBParameters:\fP
.RS 4
\fIwm\fP Pointer to a \fBwiimote_t\fP structure\&. 
.RE
.PP

.PP
Definition at line 200 of file events\&.c\&.
.SS "void propagate_event (struct \fBwiimote_t\fP *wm, \fBbyte\fPevent, \fBbyte\fP *msg)"

.PP
Analyze the event that occured on a wiimote\&. \fBParameters:\fP
.RS 4
\fIwm\fP An array of pointers to \fBwiimote_t\fP structures\&. 
.br
\fIevent\fP The event that occured\&. 
.br
\fImsg\fP The message specified in the event packet\&.
.RE
.PP
Pass the event to the registered event callback\&. 
.PP
Definition at line 248 of file events\&.c\&.
.SS "static void save_state (struct \fBwiimote_t\fP *wm)\fC [static]\fP"

.PP
Save important state data\&. \fBParameters:\fP
.RS 4
\fIwm\fP A pointer to a \fBwiimote_t\fP structure\&. 
.RE
.PP

.PP
Definition at line 750 of file events\&.c\&.
.SS "static int state_changed (struct \fBwiimote_t\fP *wm)\fC [static]\fP"

.PP
Determine if the current state differs significantly from the previous\&. \fBParameters:\fP
.RS 4
\fIwm\fP A pointer to a \fBwiimote_t\fP structure\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if a significant change occured, 0 if not\&. 
.RE
.PP

.PP
Definition at line 813 of file events\&.c\&.
.SS "int wiic_poll (struct \fBwiimote_t\fP **wm, intwiimotes)"

.PP
Poll the wiimotes for any events\&. \fBParameters:\fP
.RS 4
\fIwm\fP An array of pointers to \fBwiimote_t\fP structures\&. 
.br
\fIwiimotes\fP The number of \fBwiimote_t\fP structures in the \fIwm\fP array\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns number of wiimotes that an event has occured on\&.
.RE
.PP
It is necessary to poll the wiimote devices for events that occur\&. If an event occurs on a particular wiimote, the event variable will be set\&. 
.PP
Definition at line 81 of file events\&.c\&.
.SS "void wiic_pressed_buttons (struct \fBwiimote_t\fP *wm, \fBbyte\fP *msg)"

.PP
Find what buttons are pressed\&. \fBParameters:\fP
.RS 4
\fIwm\fP Pointer to a \fBwiimote_t\fP structure\&. 
.br
\fImsg\fP The message specified in the event packet\&. 
.RE
.PP

.PP
Definition at line 387 of file events\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for OpenGL Flythrough from the source code\&.
